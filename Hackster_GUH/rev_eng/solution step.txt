1. file rev         -> confirm ELF x86_64
2. objdump -d rev   -> find input-check loop (fgets, sub/xor/cmp)


3. objdump -s -j .rodata rev -> extract table bytes

So the bytes you need are the first continuous non-ASCII bytes that start at 0x2010.
The first 27 bytes (the length the program checks against) are: 

0xaf 0xe3 0xa0 0xa8 0xa2 0xe3 0xa2 0xe2 0x9b 0xeb 0xa8 0x98 0x96
0xe8 0xac 0x99 0xed 0x91 0xeb 0x80 0xef 0x9f 0xd1 0x84 0x9f 0xd6 0x93



4. compute input with inverse formula: 

# rev_solve.py
# table[] = bytes extracted from .rodata (first 27 bytes starting at 0x2010)
table = [
    0xAF, 0xE3, 0xA0, 0xA8, 0xA2, 0xE3, 0xA2, 0xE2, 0x9B,
    0xEB, 0xA8, 0x98, 0x96, 0xE8, 0xAC, 0x99, 0xED, 0x91,
    0xEB, 0x80, 0xEF, 0x9F, 0xD1, 0x84, 0x9F, 0xD6, 0x93
]

res = []
for i, t in enumerate(table):
    # inverse formula of: table[i] == ((input - i) ^ 0x67) ^ 0xAB
    b = ((t ^ 0x67 ^ 0xAB) + i) & 0xFF
    res.append(b)

secret = bytes(res).decode('ascii', errors='replace')
print(secret)



5. test: printf "%s\n" "PASSPHRASE" | ./rev  (run inside Docker if macOS)

